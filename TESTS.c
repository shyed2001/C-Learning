/*@Shyed Shahriar Housaini
Copyright: @uthor*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <windows.h>
///#include <threads.h>
#include <conio.h>
#include <dos.h>
#include <direct.h>
#include <math.h>
#include <stdbool.h>
#include "validtrianglecheck2.c"   /// Saved file with function in same directory.


/*@Shyed Shahriar Housaini
Copyright: @uthor*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <windows.h>
///#include <threads.h>
#include <conio.h>
#include <dos.h>
#include <direct.h>
#include <math.h>
#include <stdbool.h>
#include <string.h>
#include <strings.h>

int main(void)


{
printf("https://docs.microsoft.com/en-us/cpp/c-language/organization-of-the-c-language-reference?view=vs-2019.\n \n");

printf(" https://docs.microsoft.com/en-us/cpp/c-language/?view=vs-2019 . \n \n");

printf(" https://docs.microsoft.com/en-us/cpp/c-language/c-language-reference?view=vs-2019 . \n \n");

printf(" https://docs.microsoft.com/en-us/cpp/build/reference/c-cpp-building-reference?view=vs-2019 . \n \n");

printf("https://docs.microsoft.com/en-us/cpp/build/reference/c-cpp-building-reference?view=vs-2019 . \n \n");

printf("https://docs.microsoft.com/en-us/cpp/?view=vs-2019 . \n \n");

printf("https://docs.microsoft.com/en-us/cpp/c-runtime-library/c-run-time-library-reference?view=vs-2019 . \n \n");

 ///int luckyNumbers[] = {1, 3, 5, 7, 9, 11, 13, 15}; /// 1 is the first element in this array.

     /// 5 is the third element.   /// 1 or the first element is indexed 0.

        printf(" Variable is a container where we can store single information. \n ");

        printf(" Arrays is a data structure and a container where we can store many information. \n\n");

        printf(R"(More reading material at - https://www.geeksforgeeks.org/const-qualifier-in-c/;)\n\n");
printf(R"(char stringarray[] = "Array"; /// This is an array of char.)\n\n"););
        printf(R"(hello\nworld\n)");


printf ("   . \n \n");
printf ("   . \n \n");
printf ("   . \n \n");
printf ("   . \n \n");
printf ("   . \n \n");
printf ("   . \n \n");
printf ("   . \n \n");
printf ("   . \n \n");
printf ("   . \n \n");
printf ("   . \n \n");
printf ("   . \n \n");
printf ("   . \n \n");
printf ("   . \n \n");
printf ("   . \n \n");
printf ("   . \n \n");
printf ("   . \n \n");
printf ("   . \n \n");
printf ("   . \n \n");
printf ("   . \n \n");
printf ("   . \n \n");
printf ("   . \n \n");
printf ("   . \n \n");


printf ("  A single \\ backslash is used before a spatial character in printf . \n \n");

printf ("  Two backslash \\ \\ in printf will show or print a single \\ in output . \n \n");

printf ("   . \n \n");



printf ("  Variables are containers to store various types of data. .  \n\n ");

printf ("  To store in a program Give variables simple but easily recognized names.   .  \n\n ");

printf (" For printing multiple lines of string in one printf function \\n can be used for new line..  \n\n ");

printf (" For printing multiple lines of string in one printf function odd numbers of backslash can be used  can be used for writing input in the function to give input of multiple lines if needed..  \n\n ");

printf (" in C programming language   int valid_triangle_check( x , y , z ); \
         or  bool valid_triangle_check( x , y , z ); can also be used .  \n\n ");

printf (" In one project int main ( void ) function in two files does not work. . \n \n ");

printf (" There should not be two main () function linked in one file or in one project. . \n \n ");

printf (" Is it always safe to declare double and take input scanf with \n conversion specifier or format specifier %lf and printf as format specifier or conversion specifier %f? . \n\n ");

printf ("       .  \n\n ");

printf ("       .  \n\n ");
printf ("       .  \n\n ");

printf ("       .  \n\n ");

printf ("       .  \n\n ");

printf ("       .  \n\n ");

printf ("       .  \n\n ");

printf ("       .  \n\n ");

printf ("       .  \n\n ");

printf ("       .  \n\n ");

printf ("       .  \n\n ");

printf ("       .  \n\n ");


printf ("       .  \n\n ");

printf ("       .  \n\n ");

printf ("       .  \n\n ");

printf ("       .  \n\n ");

printf ("       .  \n\n ");

printf ("       .  \n\n ");

printf ("       .  \n\n ");

printf ("       .  \n\n ");

printf ("    Operator Overloading Similar to function overloading, operator overloading allows programmers to redefine operators such as +, - and *. For example, in a class for complex numbers where each number has a real and imaginary part, overloaded operators allow code such as this to work: As long as + is overloaded for the type complex. Advantages of Overloading When Writing Code You end up with code that is easier to read \n \
Overloading is convenient and intuitive Avoids clunky syntax Consistency in naming and notation \n \
Works well in templates and other constructs when you don't know the variable type at the time you are writing the code.   .  \n\n ");

printf ("    An Example of Function Overloading \n \ Rather than have a differently named function to sort each type of array, such as: You can use the same name with different parameter types as shown here: \n \
The compiler is then able to call the appropriate function depending on the parameter type. Overload resolution is the term given to the process of selecting the appropriate overload function.    .  \n\n ");

printf ("    In C, C++, C# and other programming languages, an identifier is a name that is assigned by the user for a program element such as variable, type, template, class, function or namespace. It is usually limited to letters, digits, and underscores. Certain words, such as new, int and break, are reserved keywords and cannot be used as identifiers. Identifiers are used to identify a program element in the code.\
        https://docs.microsoft.com/en-us/cpp/c-language/c-identifiers?view=vs-2019  .  \n\n ");

return 0;

/// Portability in C:

/** When we talk about C source code portability, we’re talking about writing the code so that it can be easily moved (ported) to another environment, so that after recompiling and relinking, it will behave the same way it did originally (ideally without any changes to the source code itself, but in practice, with only minimal changes).

What do we mean by “another environment?”

Moving to a different operating system on the same hardware.
Moving to a different version of the same operating system on the same hardware.
Moving to a different variant/flavor/distribution of an operating system.
Moving to a different CPU hardware architecture.
Moving to a different C compiler on the same hardware and operating system.
Moving to a different version of the same C compiler on the same hardware and operating system. (Yes, code can break between versions of a compiler offered by the same compiler vendor.)
Why do we want portable code?

The act of porting the code takes time and effort (and therefore has a cost), in terms of understanding exactly what has to change, making the change(s), and testing the modified code. If we can reduce the number of required changes to zero, or to a very small number of isolated changes, we can reduce the porting effort and project cost.

So, how do we strive to achieve portability?

Here is a partial list to give you some idea of what to worry about:

Don’t assume the size of any data type. Data type sizes can and do vary from one environment to another. For example, an int might be 16 bits, 32 bits, 64 bits, or more. It might vary between compilers for the exact same hardware. It might change from one compiler version to another. The size of an int may or may not have any relationship to the natural word size of the CPU hardware.
Don’t assume that a pointer (to anything) is the same size as an int or the same size as any other data type. Pointers are sometimes the same size as an int, but are often a different size from an int. For example, in many popular compilers, building for a 32-bit target gives you a 32-bit int and a 32-bit pointer, but building the same code with the same compiler for a 64-bit target gives you a 32-bit int and a 64-bit pointer.
Don’t make calls directly to the operating system. Instead, use standard library functions.
Don’t make assumptions about the underlying hardware, speed, memory size, memory map, I/O map, etc.
Don’t assume a specific endianness (byte ordering) of the target system. Not only can endianness vary from one CPU architecture to another, but some CPU architectures allow switching between big and little endian.
Avoid the use of bit fields in structures, if you’re relying on a specific packing/ordering of the bit fields. Handling of bit fields varies between implementations.
Don’t assume that structure packing/padding will be the same in all environments. Packing and padding behaviors can and do vary between compiler implementations, even when targeting the same CPU hardware.
Don’t embed assembly language in the source code. By definition, the code will break if you try to port it to a different CPU architecture.
Don’t use compiler intrinsics or compiler-specific keywords and pragmas. Obviously, not ever compiler implementation will have these features, so for maximum portability, avoid them.
Avoid the use of newer language features that have not been widely adopted. Some people are really taken aback by this rule, but it has a very practical purpose. For example, variable-length arrays have been part of the C standard since C99. But many compiler implementations have never supported the feature, so porting code that uses this feature becomes a problem. (The C11 standard has demoted this language feature to optional, so it’s even more likely that many compilers will never implement the feature.)
Avoid all other undefined behavior and implementation-specific behavior. Your code might appear to work in one environment, and fall apart as soon as you try to port it another environment. This requires some common sense and a knowledge of what is undefined and implementation-specific. Many compilers produce helpful warnings when code ventures into these areas, but many don’t say anything at all.
If you must violate these rules for some reason, it’s best to isolate that code in a separate module, so that the porting work is isolated and minimized.

Even if you don’t intend to port your code beyond its initial target, it’s a good idea to keep portability in mind in all projects - you just never know where your code is going to end up.  **/


/// In stdlib.h the macros EXIT_SUCCESS and EXIT_FAILURE are defined like this : #define EXIT_SUCCESS 0; #define EXIT_FAILURE 1

/// These 2 macros can be used as the argument to the exit function declared in stdlib.h and they can also be used as the return value of the main function.
/// In C and C++ programs the main function is of type int and therefore it should return an integer value. The return value of the main function is considered the "Exit Status" of the application. On most operating systems returning 0 is a success status like saying "The program worked fine"

/// Traditionally, on UNIX-like systems, returning 0 from your main function (or, almost equivalently, calling exit(0) from anywhere in your program) terminates the program and tells the environment that it succeeded, while returning any non-zero value indicates that it failed (with 1 typically denoting a generic failure). But not all operating systems use that same convention.

///The C standard defines meanings for return values of 0, EXIT_SUCCESS, and EXIT_FAILURE (the latter two are macros defined in <stdlib.h>). It doesn’t define any particular meaning for returning 1 — and there are systems (OpenVMS) where return 1; denotes success.

/// For portability and clarity, use EXIT_SUCCESS or EXIT_FAILURE — but return 1; to denote failure is OK if your program is only intended to be run on a UNIX-like system.

///One aspect of #define EXIT_SUCCESS  0 ;  #define EXIT_FAILURE  1

/// is that other programs, shells, and scripts must look for 0 as the wanted response when they launch a program.

/// For this reason script languages such as bash are designed to treat 0 as true in conditional expressions. This trips people up because it is counter-intuitive when most programming languages internally treat 0 as false in conditional expressions. But it is this return 0 aspect that is responsible for that.
/// In every C program you have to use return return 0; (or return -1;, or whatever... ), because the main function signature requires it. In a C++ program the statement is optional: the compiler automatically adds a return 0; if you don't explicitely return a value. The return value is the exit code of your program, the shell (or any other application that ran it) can read and use it. The 0 exit code is a widely accepted convention for 'OK the program execution was successfull'.

}

/// In C programming, what is the difference between bool and _Bool?
/// In C, _Bool is a keyword that has been officially part of the the language starting with the C99 standard. If you use _Bool as a data type, you don’t have to include anything special… it’s just another keyword. The standard says that _Bool is a data type large enough to store the values 0 and 1. In theory, that’s only one bit, but in practice, it typically occupies a byte. _Bool is considered a standard unsigned integer data type. When dealing with integer conversion, the rank of _Bool is less than the rank of all other standard integer data types. Of course, your compiler has to support it before you can use it. Not all compilers support all features of the C99 standard, even today. So, check your compiler documentation to see if it’s in the list of keywords. The reason the _Bool keyword looks so strange is that the standards committee realized lots of existing software may have defined and used “bool”, so the the leading underscore and uppercase letter are part of the new keyword to avoid breaking existing code. (They used the same strategy for the _Complex and _Imaginary keywords, which were also added in C99, and the seven other keywords that have been added to the language since then.) Now, if your code doesn’t already define or use the identifiers bool, true, and false for anything, the C99 standard offers a header file stdbool.h, which defines bool as an alias for _Bool, and also defines symbols for the true and false values. C++ already has bool, true, and false as keywords. In C, assuming your compiler implementation supports it, including stdbool.h and using bool, true, and false are forward compatible with C++, you can avoid using the odd-looking _Bool keyword and avoid rolling your own values for true and false. In most of the organizations I’ve worked with that have C coding standards, the standard practice in new C code is to include stdbool.h and use bool, true, and false.

/** Almost nobody would have an in-code datatype named _Bool, but nearly all large C projects had code that did something like this

typedef int bool;
#define BOOL_TRUE (1)
#define BOOL_FALSE (0)
bool mybool = BOOL_FALSE;
If you included stdbool.h in this code, it would fail to build, but you can still keep building it in a C99 compiler by simply “skipping” stdbool.h as there’s no references to the builtin _Bool datatype.

It’s also worth noting that trying to do something like

#include <stdbool.h>**/
/* typedef int bool */
/** #define BOOL_TRUE (true)
#define BOOL_FALSE (false)
bool mybool = BOOL_FALSE;
would work in C99, but would now fail to compile in older compilers, which is why a big project would hold off on doing this until the group maintaining the project stopped supporting pre-C99 compilers. **/


/**
What does .h mean in C?
. h is an extension for a header file which is used to define various functions, variables or constants in a function library that you may want to use. It consists of functions classes and API required for programming.

They are included in the program using a #include statement.

For e.g. #include “stdio.h” incudes the standard input Output functions - printf and scanf.
A .h file is a header file. Good practice when writing large programs in C is to separate the code into separate files, where each file deals with one narrow problem domain. (If this sounds like a predecessor of object-orientation, that’s not completely wrong.)

But the problem then becomes how to find functions in other files that you need to call. The convention is for the code of a module to be in a file named module.c, while declarations of functions that are available to be called from elsewhere in the program are placed in a header file called module.h. In the header file also go things like type declarations that will be needed by users of your module, any macro or symbol definitions, and so on.

That way, when you’re building your program, if a module in another file needs to call your module, it can include module.h and get the declarations that will allow the compiler to know what parameters will get passed to your functions, and how to allocate memory for variables of types that you have declared. It does not need to include the base module.c file which has all the code for your module, and which has far too much detail to be easy to work with.

In fact, if the module you’re including isn’t one you wrote yourself, you may not even have access to the .c file that goes with the .h file. (For example, the C standard library: stdio.h, stdint.h, etc.) But as long as your module.c file #includes the correct header file that describes how to call the functions that are in the library, your compiler will be able to compile your module so that it can call out to library functions successfully and the linker will be able to link those calls to the right library file, even if you don’t have the .c file that goes with it.

“.h” files in C are “headers” files.

They declare functions, structures, global variables and any C construction so you can use them in your module (the .c file where you put an #include <….h> statement). By “use” I mean it allows your .c module to compile successfully (note: compile only, also known as “obtaining an .o module out of your .c module”; I’m excluding here the linking process, which converts your .o file into an executable file).

These .h headers files are not the actual implementation of the things it declares. The implementation of anything in C always lays in a .o module (or a .lib (library) module which is a collection of .o files -let me ignore dynamic link libraries for this answer-).

OK. So if by including .h files I don’t get the implementation of the things they declare. How would I get my module to produce a working order exectuable program? Answer: you get your executable by linking your compiled .o files with other .o or .lib files.

As you can see “compiling” in C is a two step process:

First compiler uses .h and .c files to produce .o files.
Then linker uses .o (and/or .lib) files to produce an executable file. Note that .h files are not used here.
Imagine you are developing a library that computes hash values with several algorithms (MD5, SHA…). You will provide users with your compiled library file (either .o files or a single .lib containing all your .o files). How would other developer compile his code using your functions? He would need the declaration of those functions.

Hence you will provide them with:

a) A .h file so they can compile (step 1 of the C “compiling” steps above).

b) A .o or .lib file (remember a library is just a collection of .o files) so they can link (step 2).

Additional notes for a more complete answer:

.lib (library) files are named .a in UNIX-like systems
There are some constructions in .h files which are used just during the compilation phase (e.g. #define directives). These do not imply anything in an .o compiled file, so it is possible to construct an .h file which does not required of a .o or .lib file to be used in your program.
You can provide a .h file or multiple .h files with your library.
**/

/**
Math.h functions

abs
ceil
cos
floor
log
log10
pow
pow10
sin
sqrt
**/

/**

**/

/**
The C compiler considers uppercase and lowercase letters to be distinct characters. This feature, called "case sensitivity," enables you to create distinct identifiers that have the same spelling but different cases for one or more of the letters. For example, each of the following identifiers is unique:
add
ADD
Add
aDD

**/


/**



**/


/**



**/





/**



**/





/**
https://docs.microsoft.com/en-us/cpp/c-language/elements-of-c?view=vs-2019
Elements of C
11/04/2016
2 minutes to read
     +1
This section describes the elements of the C programming language, including the names, numbers, and characters used to construct a C program. The ANSI C syntax labels these components tokens.

This section explains how to define tokens and how the compiler evaluates them.

The following topics are discussed:

Tokens

Comments

Keywords

Identifiers

Constants

String literals

Punctuation and special characters

The section also includes reference tables for Trigraphs, Limits on Floating-Point Constants, C and C++ Integer Limits, and Escape Sequences.

Operators are symbols (both single characters and character combinations) that specify how values are to be manipulated. Each symbol is interpreted as a single unit, called a token. For more information, see Operators.

**/


/**
C Identifiers
11/04/2016
3 minutes to read

"Identifiers" or "symbols" are the names you supply for variables, types, functions, and labels in your program. Identifier names must differ in spelling and case from any keywords. You cannot use keywords (either C or Microsoft) as identifiers; they are reserved for special use. You create an identifier by specifying it in the declaration of a variable, type, or function. In this example, result is an identifier for an integer variable, and main and printf are identifier names for functions.


Copy
#include <stdio.h>

int main()
{
    int result;

    if ( result != 0 )
        printf_s( "Bad file handle\n" );
}
Once declared, you can use the identifier in later program statements to refer to the associated value.

A special kind of identifier, called a statement label, can be used in goto statements. (Declarations are described in Declarations and Types Statement labels are described in The goto and Labeled Statements.)

Syntax
identifier:
    nondigit
    identifier nondigit
    identifier digit

nondigit: one of
    _ a b c d e f g h i j k l mn o p q r s t u v w x y z
    A B C D E F G H I J K L MN O P Q R S T U V W X Y Z

digit: one of
    0 1 2 3 4 5 6 7 8 9

The first character of an identifier name must be a nondigit (that is, the first character must be an underscore or an uppercase or lowercase letter). ANSI allows six significant characters in an external identifier's name and 31 for names of internal (within a function) identifiers. External identifiers (ones declared at global scope or declared with storage class extern) may be subject to additional naming restrictions because these identifiers have to be processed by other software such as linkers.

Microsoft Specific

Although ANSI allows 6 significant characters in external identifier names and 31 for names of internal (within a function) identifiers, the Microsoft C compiler allows 247 characters in an internal or external identifier name. If you aren't concerned with ANSI compatibility, you can modify this default to a smaller or larger number using the /H (restrict length of external names) option.

END Microsoft Specific

The C compiler considers uppercase and lowercase letters to be distinct characters. This feature, called "case sensitivity," enables you to create distinct identifiers that have the same spelling but different cases for one or more of the letters. For example, each of the following identifiers is unique:


Copy
add
ADD
Add
aDD
Microsoft Specific

Do not select names for identifiers that begin with two underscores or with an underscore followed by an uppercase letter. The ANSI C standard allows identifier names that begin with these character combinations to be reserved for compiler use. Identifiers with file-level scope should also not be named with an underscore and a lowercase letter as the first two letters. Identifier names that begin with these characters are also reserved. By convention, Microsoft uses an underscore and an uppercase letter to begin macro names and double underscores for Microsoft-specific keyword names. To avoid any naming conflicts, always select identifier names that do not begin with one or two underscores, or names that begin with an underscore followed by an uppercase letter.

END Microsoft Specific

The following are examples of valid identifiers that conform to either ANSI or Microsoft naming restrictions:


Copy
j
count
temp1
top_of_page
skip12
LastNum
Microsoft Specific

Although identifiers in source files are case sensitive by default, symbols in object files are not. Microsoft C treats identifiers within a compilation unit as case sensitive.

The Microsoft linker is case sensitive. You must specify all identifiers consistently according to case.

The "source character set" is the set of legal characters that can appear in source files. For Microsoft C, the source set is the standard ASCII character set. The source character set and execution character set include the ASCII characters used as escape sequences. See Character Constants for information about the execution character set.

END Microsoft Specific

An identifier has "scope," which is the region of the program in which it is known, and "linkage," which determines whether the same name in another scope refers to the same identifier. These topics are explained in Lifetime, Scope, Visibility, and Linkage.
**/


/**

**/


/**

**/


/** https://www.thoughtco.com/
Int Limitations
Only whole numbers can be stored in int variables, but because they can store both positive and negative numbers, they're also considered signed.

For example, 27, 4908 and -6575 are valid int entries, but 5.6 and b are not. Numbers with fractional parts require a float or double type variable, both of which can contain decimal points.

The size of number that can be stored in int usually is not defined in the language, but instead depends on the computer running the program. In C#, int is 32 bits, so the range of values is from -2,147,483,648 to 2,147,483,647. If larger values are required, the double type can be used.

What Is Nullable Int?
Nullable int has the same range of values as int, but it can store null in addition to whole numbers. You can assign a value to nullable int just as you would for int, and you can also assign a null value.

Nullable int can be useful when you want to add another state (invalid or uninitialized) to a value type. Nullable int cannot be used in loops since loop variables must always be declared as int.

Int vs. Float and Double
Int is similar to the float and double types, but they serve different purposes.

Int:

Takes up less space than other types
Has faster arithmetic
Uses only whole numbers
Uses caches and data transfer bandwidth more efficiently
Float and double types:

Uses twice as much memory
Can contain a decimal point
Can contain more characters
The difference between float and double types lies in the range of values. The range of double is twice that of float, and it accommodates more digits.

Note: INT is also used as a formula in Microsoft Excel to round numbers down, but it has nothing to do with int as described on this page.
**/



/** https://www.thoughtco.com/

Uses for Double
The float type, which has a smaller range, was used at one time because it was faster than the double when dealing with thousands or millions of floating-point numbers. Because calculation speed has increased dramatically with new processors, however, the advantages of floats over doubles are negligible. Many programmers consider the double type to be the default when working with numbers that require decimal points.

Double vs. Float and Int
Other data types include float and int. The double and float types are similar, but they differ in precision and range:

A float is a single precision, 32-bit floating-point data type that accommodates seven digits. Its range is approximately 1.5 × 10−45 to 3.4 × 1038.
A double is a double-precision, 64-bit floating-point data type. It accommodates 15 to 16 digits, with a range of approximately 5.0 × 10−345 to 1.7 × 10308.
The int also deals with data, but it serves a different purpose. Numbers without fractional parts or any need for a decimal point can be used as int. Thus, the int type holds only whole numbers, but it takes up less space, the arithmetic is usually faster, and it uses caches and data transfer bandwidth more efficiently than the other types.
**/




/** https://www.thoughtco.com/
Uses for Float
Float is used mostly in graphic libraries because of their extremely high demand for processing power. Because the range is smaller than in the double type, float has been the better choice when dealing with thousands or millions of floating-point numbers because of its speed. The advantage of float over double is negligible, however, because calculation speed has increased dramatically with new processors. Float is also used in situations that can tolerate rounding errors that occur due to the float precision of seven digits.

Currencies are another common use for float. Programmers can define the number of decimal places with additional parameters.

Float vs. Double and Int
Float and double are similar types. Float is a single-precision, 32-bit floating point data type; double is a double-precision, 64-bit floating point data type. The biggest differences are in precision and range.

Double: The double accommodates 15 to 16 digits, compared with float's seven. The range of double is 5.0 × 10−345 to 1.7 × 10308.

Int: Int also deals with data, but it serves a different purpose. Numbers without fractional parts or any need for a decimal point can be used as int. The int type holds only whole numbers, but it takes up less space, the arithmetic is usually faster than with other types, and it uses caches and data transfer bandwidth more efficiently.
**/






/**
In C programming data types play a major role, so is their size and range. The sizeof() operator gives you bytes required to store value of some type in memory. However, in programming you must be aware of range of a type to avoid overflow and underflow errors.

The size of a data type is compiler dependent and so is its range. So, you must not hardcode size and range values in your program.
There are two ways to find minimum and maximum range of a type. You can use any of the approach to get range of a type.

Find range of data types manually without C library
The minimum and maximum range of a signed type is given by -
-(2N-1) to 2N-1 - 1 (Where N is sizeof(type) * 8 i.e. total number of bits used by the type)

The minimum and maximum range of an unsigned type is given by -
0 to (2N-1) + (2N-1 - 1)


**/






/**

https://codeforwin.org/2017/08/data-types-in-c-programming.html

List of all data types in C programming
In the series of learning programming, we learned about data types. Data type is a system for defining various properties of data stored in memory. Properties such as, type of data, range of data, bytes occupied etc.

Data type in C programming is categorized three categories.
Primitive data type
Derived data type
User defined type
Read more - List of all format specifiers or conversion specifier in C


Below is the list of all primitive and derived type in C programming.

List of primitive and derived data type in C
Data type	Size	Range	Description
char	1 byte	-128 to 127	A character
signed char
unsigned char	1 byte	0 to 255	A character
short	2 bytes	−32,767 to 32,767	Short signed integer of minimum 2 bytes
signed short
signed short int
unsigned short	2 bytes	0 to 65,535	Short unsigned integer of minimum 2 bytes
unsigned short int
int	2 or 4 bytes	-32,768 to 32,767 or -2,147,483,648 to 2,147,483,647	An integer (Both positive as well as negative)
signed int
unsigned int	2 or 4 bytes	0 to 65,535 or 0 to 4,294,967,295	An unsigned integer (Positive integer)
long	4 bytes	-2,147,483,648 to 2,147,483,647	Long signed integer of minimum 4 bytes
signed long
signed long int
unsigned long	4 bytes	0 to 4,294,967,295	Long unsigned integer of minimum 4 bytes
unsigned long int
long long	8 bytes	-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807	Integer with doubled capacity as of long
long long int
signed long long
signed long long int
unsigned long long	8 bytes	0 to 18,446,744,073,709,551,615	Unsigned integer with doubled capacity as of long
unsigned long long int
float	4 bytes	1.2E-38 to 3.4E+38	Single precision floating point number
double	8 bytes	2.3E-308 to 1.7E+308	Double precision floating point number
long double	12 bytes	3.4E-4932 to 1.1E+4932	Double precision floating point number
Important note: Size and range of data type is compiler dependent which may vary.
**/






/**
Difference between C and Ansi C:
Main difference: C was originally developed by Dennis Ritchie at AT&T Bell Labs between 1969 and 1973. It has a free-format program source code. C is a general-purpose programming language. C is one of the oldest currently used programming languages and is one of the most widely used programming languages. ANSI C is a set of successive standards which were published by the American National Standards Institute (ANSI) for the C programming language. The ANSI specifies the syntax and semantics of programs written in C.

Some other differences between C and ANSI C:

ANSI C allows the inclusion of a function prototype which gives the type of the function and the type of each parameter before defining the function.
In C, function declarations are assumed by default to be of type int. Hence, integer type functions need not declared at all.
In C, function headers have different syntax.
Function prototypes must be declared without a list of arguments and types, and consist of the type, function name and an empty set of parentheses.
C converts all float types in an expression to double precision types.
The type signed char is not available in C, but is in ANSI C.
In C, type void is not available.
In C, functions are assumed to return integer if they return nothing.
Many old C compilers expect that the first character of a preprocessor directive line is a #. No leading white space is allowed.
In C, the signed type qualifier is not available.
In C, the unsigned qualifier can be used to qualify integer types only.
In C, the unary positive sign is not allowed.
In C, the type long double is not available.
In C, the const qualifier is not available.
In C, enumeration type is not available.
Automatic arrays cannot be initialized in declarations in C. Only external and static arrays can be initialized.
Automatic structures and arrays of structures cannot be initialized in declarations in C.
In C, Some old compilers may not allow references to entire structures, requiring the use of structure pointers or individual structure members.

**/


/**
https://codeforwin.org/2015/05/list-of-all-format-specifiers-in-c-programming.html

Format specifier	Description	Supported data types
%c	Character	char
unsigned char
%d	Signed Integer	short
unsigned short
int
long
%e or %E	Scientific notation of float values	float
double
%f	Floating point	float
%g or %G	Similar as %e or %E	float
double
%hi	Signed Integer(Short)	short
%hu	Unsigned Integer(Short)	unsigned short
%i	Signed Integer	short
unsigned short
int
long
%l or %ld or %li	Signed Integer	long
%lf	Floating point	double
%Lf	Floating point	long double
%lu	Unsigned integer	unsigned int
unsigned long
%lli, %lld	Signed Integer	long long
%llu	Unsigned Integer	unsigned long long
%o	Octal representation of Integer.	short
unsigned short
int
unsigned int
long
%p	Address of pointer to void void *	void *
%s	String	char *
%u	Unsigned Integer	unsigned int
unsigned long
%x or %X	Hexadecimal representation of Unsigned Integer	short
unsigned short
int
unsigned int
long
%n	Prints nothing
%%	Prints % character


**/



/**
int main() {
    char c;
    printf("Enter a character: ");
    scanf("%c", &c);

    if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
        printf("%c is an alphabet.", c);
    else
        printf("%c is not an alphabet.", c);

    return 0;
}

**/




/**
*
int main(void)
{

    float dnum = 7777.0000;
    printf(" %f \n", dnum);
        return 0;
}


int x, y, z, A, B;  /// Have to use int ?


int valid_triangle_check( x , y , z ); ///  imported function   Saved file with function in same directory.

int main()
{
   ///int x, y, z, A, B;

printf (" Please enter the first arm length of triangle :  ");

scanf(" %d", &x);   /// Have to use %d ?

printf (" Please enter the second arm length of triangle :  ");

scanf(" %d", &y); /// Have to use %d ?


printf (" Please enter the third arm length of triangle :  ");

scanf(" %d", &z); /// Have to use %d ?

printf (" Result\n ");

 /** if ( x <=0 || y <= 0 || z <= 0 )
    {
        printf(" Invalid Length");
        //return 0 ;
    }

 else if ( x + y <z || y + z < x || z + x < y )
    {
        printf(" Invalid Triangle ");
        //return 0 ;
    }


 else
    {
        printf(" Valid Triangle ");
        //return 1 ;



      if ( valid_triangle_check( x , y , z ) == true )

  {
      printf (" valid triangle\n");
  }

  else ///( valid_triangle_check( x , y , z ) == false )

  {
      printf (" Invalid triangle\n");
  }

return 0;

}
    } **/







/**

if ( valid_triangle_check( x , y , z ) == 1 )

  {
      printf (" valid triangle\n");
  }

  else ///( valid_triangle_check( x , y , z ) == false )

  {
      printf (" Invalid triangle\n");
  }

**/


/**
int valid_triangle_check( x , y , z )

{

 if ( x <=0 || y <= 0 || z <= 0 )
    {
        printf(" Af ");
        return 0 ;
    }

 else if ( x + y <z || y + z < x || z + x < y )
    {
        printf(" Bf ");
        return 0 ;
    }


 else
    {
        printf(" t ");
        return 1 ;
    }

}

**/

/** else if ( x + y <z  )
    {
        printf(" Bf1 ");
        return false ;
    }

else if (y + z < x)
    {
        printf(" Bf2 ");
        return false ;
    }
else if ( z + x < y )
    {
        printf(" Bf3 ");
        return false ;
    }**/
